#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Синюков А.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Поиск в пространстве состояний сводится к задаче на поиск в графе, сгенерированном по правилам перехода между состояниями. Задачи поиска оптимального пути достаточно удобно и эффективно решаются с помощью языка программирования Prolog. Prolog сам выполняет код строя дерево, и выводит результаты в виде его обхода в ширину, так что на нем не сложно реализовать алгоритмы обхода графов (dfs, bfs, с итеративным погружением).


## Задание

5. Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром.

## Принцип решения

Для построения графа требуется написать правила "движения", т.е. переходы между одним состоянием и другим:    
1) черный шар двигается налево если свободно    
2) белый шар двигается направо если свободно    
3) если слева от белого шара пусто, а справа черный шар, то черный шар перемещается в пустую клетку    
4) если справа от черного шара пусто, а слева белый шар, то белый шар перемещается в пустую клетку    
```prolog
move(A,B) :-
    append(H,['_','b'|T],A),
    append(H,['b','_'|T],B).
    
move(A,B) :-
    append(H,['w','_'|T],A),
    append(H,['_','w'|T],B).

move(A,B) :-
    append(H,['_','w','b'|T],A),
    append(H,['b','w','_'|T],B).

move(A,B) :-
    append(H,['w','b','_'|T],A),
    append(H,['_','b','w'|T],B).
```
В данной задаче использовались алгоритмы поиска в глубину, поиска в ширину и в глубину с итеративным погружением:
1)BFS:    
```prolog
bdth([[H|T]|_], H, [H|T]).

bdth([H|T], X, Z) :-
    findall(W, prolong(H, W), Y),
    append(T, Y, E), !,
    bdth(E, X, Z).

bdth([_,T], X, Y) :- bdth(T, X, Y).
```
2)DFS:    
```prolog
ddth([[H|T]|_], H, [H|T]).

ddth([H|T], X, Z) :-
    findall(W, prolong(H, W), Y),
    append(Y, T, E), !,
    ddth(E, X, Z).

ddth([_,T], X, Y) :- ddth(T, X, Y).
```
3)C итеративным погружением:
```prolog
depth_id([H|T], H, [H|T], 0).

depth_id(W, X, Y, N) :-
    N>0,
    prolong(W, NEW),
    N1 is N-1,
    depth_id(NEW, X, Y, N1).
```

## Результаты
```prolog
1 ?- dfs(['w','w','w','_','b','b','b'],['b','b','b','_','w','w','w']).
dfs:
[w,w,w,_,b,b,b]
[w,w,w,b,_,b,b]
[w,w,_,b,w,b,b]
[w,_,w,b,w,b,b]
[w,b,w,_,w,b,b]
[w,b,w,b,w,_,b]
[w,b,w,b,w,b,_]
[w,b,w,b,_,b,w]
[w,b,_,b,w,b,w]
[_,b,w,b,w,b,w]
[b,_,w,b,w,b,w]
[b,b,w,_,w,b,w]
[b,b,w,b,w,_,w]
[b,b,w,b,_,w,w]
[b,b,_,b,w,w,w]
[b,b,b,_,w,w,w]
time: 0.020946979522705078
true.

2 ?- bfs(['w','w','w','_','b','b','b'],['b','b','b','_','w','w','w']).
bfs:
[w,w,w,_,b,b,b]
[w,w,w,b,_,b,b]
[w,w,_,b,w,b,b]
[w,_,w,b,w,b,b]
[w,b,w,_,w,b,b]
[w,b,w,b,w,_,b]
[w,b,w,b,w,b,_]
[w,b,w,b,_,b,w]
[w,b,_,b,w,b,w]
[_,b,w,b,w,b,w]
[b,_,w,b,w,b,w]
[b,b,w,_,w,b,w]
[b,b,w,b,w,_,w]
[b,b,w,b,_,w,w]
[b,b,_,b,w,w,w]
[b,b,b,_,w,w,w]
time: 0.0074350833892822266
true.

3 ?- search_id(['w','w','w','_','b','b','b'],['b','b','b','_','w','w','w']).
id:
[w,w,w,_,b,b,b]
[w,w,w,b,_,b,b]
[w,w,_,b,w,b,b]
[w,_,w,b,w,b,b]
[w,b,w,_,w,b,b]
[w,b,w,b,w,_,b]
[w,b,w,b,w,b,_]
[w,b,w,b,_,b,w]
[w,b,_,b,w,b,w]
[_,b,w,b,w,b,w]
[b,_,w,b,w,b,w]
[b,b,w,_,w,b,w]
[b,b,w,b,w,_,w]
[b,b,w,b,_,w,w]
[b,b,_,b,w,w,w]
[b,b,b,_,w,w,w]
time: 0.012777090072631836
true.
```

## Выводы

Пролог оказался довольно эффективен для решения задачи на поиск в пространстве состояний. Всё, вплоть до выполнения кода языком было создано для решения задач в графах или деревьях.    
Все три алгоритма показали достаточно быстрое время работы для данной задачи, и то, какой алгоритм окажется эффективнее в следующий раз сказать сложно. Но в среднем лучше всего справлялся алгоритм поиска в глубину с итеративным погружением, а поиск в глубину ни разу не был лучшим, так как может пойти по не самому оптимальному маршруту. Но если первый маршрут для DFS окажется самым быстрым в принципе, из-за выполнения кода в языке Prolog по такому же принципу, DFS может стать лучшим.
