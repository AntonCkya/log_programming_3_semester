#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Синюков А.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пролог идеально подходит для решения логических задач, так как внутри себя строит дерево решений, на основе которых работают подходы к решению логических задач:   
1)Метод порождения и проверок - строится дерево всех решений, и на основе условий задачи отсекаются неправильные. Долго и дорого     
2)Метод ветвей и границ - дерево строится одновременно с проверкой решений. Программа тогда отсекает неправильные решения ветвями, что ускоряет работу.

## Задание

20) Дина, Соня, Коля, Рома и Миша учатся в институте. Их фамилии Бойченко, Карпенко, Лысенко, Савченко и Шевченко. Мать Ромы умерла. Родители Дины никогда не встречались с родителями Коли. Студенты Шевченко и Бойченко играют в одной баскетбольной команде. Услышав, что родители Карпенко собираются поехать за город, мать Шевченко пришла к матери Карпенко и попросила, чтобы та отпустила своего сына к ним на вечер, но оказалось, что отец Коли уже договорился с родителями Карпенко и пригласил их сына к Коле. Отец и мать Лысенко хорошие друзья родителей Бойченко. Все четверо очень довольны, что их дети собираются пожениться. Установите имя и фамилию каждого из молодых людей и девушек.

## Принцип решения

За решение отвечает предикат solve\1, который выводит ответ в виде списка, со значениями person(name, surname).
```
solve(Solve) :-
	Solve = [
		person(A, "Бойченко"),
		person(B, "Карпенко"),
		person(C, "Лысенко"),
		person(D, "Савченко"),
		person(E, "Шевченко")
	],
```
Внутри предиката происходят проверки на данные в задачи условия:   
Проверка на уникальность каждого из имени:
```
unique([A, B, C, D, E]),
```
Проверка на гендер (из задачи можно узнать, что Карпенко мужского пола, а также совпадение/несовпадение некоторых из них):
```
gender(B, male), % у Карпенко сын
same_gender(E, A), % Предположим, что в одной баскетбольной команде играют люди одного пола
diff_gender(C, A), % Они собираются пожениться
```
Проверка на наличие в семье матери (у Ромы нет):
```
has_mom(E), % мать Шевченко 
has_mom(B), % пришла к матери Карпенко
has_mom(C), % "Все четверо очень довольны" - видимо тоже живы матери
has_mom(A),
```
Проверка на то, знают ли родители друг друга (из описаний взаимодействий людей однозначно понятно кто кого знает):
```
parents_knows(E, B), % "мать Шевченко пришла к матери Карпенко" - видимо знакомы
parents_knows(B, "Коля"), % Карпенко знают родителей Коли
parents_knows(A, C). % Отец и мать Лысенко хорошие друзья родителей Бойченко
```
Отдельная провека на то, чтобы Коля не был Карпенко (из условия):
```
name_exception(B, "Карпенко"),
```
Вспомогательные предикаты (для работы со списками использовались встроенные в SWI Prolog предикаты):
```
same_gender(X, Y) :- gender(X, A), gender(Y, A).
diff_gender(X, Y) :- not(same_gender(X, Y)).

no_mother("Рома"). % Мать Ромы умерла
has_mom(X) :- not(no_mother(X)).

not_name("Коля", "Карпенко"). % "Отец Коли уже договорился с родителями Карпенко" - значит Коля не Карпенко
name_exception(X, Y) :- not(not_name(X, Y)).

parents_not_knows("Коля", "Дина"). % Родители Дины никогда не встречались с родителями Коли
parents_knows(X, Y) :- not(parents_not_knows(X, Y)), not(parents_not_knows(Y, X)).

unique([]) :- !.
unique([A|B]) :- member(A, B), !, fail; unique(B).
```
Ответ:
```
?- solve(X).
X = [person("Соня", "Бойченко"), person("Миша", "Карпенко"), person("Коля", "Лысенко"), person("Рома", "Савченко"), person("Дина", "Шевченко")]
```
## Выводы
Пролог оказался очень удобен для решения логических задач. В отличии от предыдущей лабораторной работы, программирование поставленой задачи ощущалось не "вопреки" возможностям языка, а исключительно "благодаря". Пролог отсекает сразу неподходщие условия, реализуя метод ветвей и границ, благодаря чему код довольно оптимизирован. Такое решение не только достаточно удобное, но и надёжное по сравнению с решением в уме или на листочке (особенно если задача усложнится), к тому же если задача расширится, то код достаточно под это расширяем, чтобы без проблем решить новую задачу. Решение подобной задачи, как по мне, заняло бы больше времени и сил на другом языке, и не думаю, что оно было бы настолько быстрым.




