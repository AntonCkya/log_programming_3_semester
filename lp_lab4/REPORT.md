#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Синюков А.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Анализ естественного языка сводтися к нескольким этапам: определение границ слов и предложений, морфологический и синтаксический анализ и определение смысла слов и предложений. Но компьютер не может проходить через эти этапы эмпирически, ему нужны некоторые алгоритмы. Выражение можно представить в виде символьного дерева и составления грамматик, а анализ самого слова можно проводить с помощью словарей.    

В языке программирования Prolog очень удобно проводить анализ естественного языка благодаря удобному описанию грамматик, которые легко использовать и приятно читать другому человеку, который захочет прочитать код. Также пролог может составлять словари, а структура дерева в нем вшита "из коробки".

## Задание

1. Генеалогическое дерево задано фактами вида:
```prolog
parent(alexei, tolia).
parent(alexei, volodia).
parent(tolia, tima).
...
```
Написать программу на Прологе, запросы к которой будут выглядеть следующим образом:
```prolog
?- answer([volodia,brat,toli,'?'], X).
?- answer([kto,tolin,brat,'?'], X).
?- answer([chei,brat,volodia,'?'], X).
```

## Принцип решения

1) Определить какие команды может ввести пользователь (можно сказать описание грамматики):    
- name, brat, name2, ?    
- kto, name, brat, ?    
- chei, brat, name, ?    
2) Проверить есть ли это имя в "базе" (словаре с падежами):
```prolog
parent(alexei, tolia).
parent(alexei, volodia).
parent(alexei, vitia).
parent(tolia, tima).

...

in_base(XC, K, X) :- cases(Dict), find(X, XC, K, Dict).
```
3) Привести имя в именительный падеж с помощью словаря падежей
4) Проходим по дереву parent для поиска братьев, или проверки на братство:
```prolog
answer([X,Y,_,_], Res) :- 
    X = 'kto',
    in_base(Y_im, case('TV'), Y),
    parent(P, Y_im), parent(P, Res), Y_im \= Res.

answer([X,_,Y,_], Res) :- 
    X = 'chei',
    in_base(Y_im, case('IM'), Y),
    parent(P, Y_im), parent(P, Res), Y_im \= Res.

answer([X,_,Y,_], _) :- 
    in_base(X_im, case('IM'), X),
    in_base(Y_im, case('ROD'), Y),
    parent(P, X_im), parent(P, Y_im), X_im \= Y_im.
```

## Результаты

```prolog
?- answer([volodia,brat,toli,'?'], X). true .

?- answer([kto,tolin,brat,'?'], X).
X = volodia ;
X = vitia ;
false.

?- answer([chei,brat,vitia,'?'], X).
X = tolia ;
X = volodia ;
false.

?- answer([volodia,brat,timi,'?'], X).
false.
```

## Выводы

Пролог отлично справляется с решением задач, связанным с разбором естественных языков. На нем очень просто задать грамматику (особенно в английском языке, где у слов более строгий порядок в предложении), а также работать с символьными деревьями (так как пролог строит деревья в процессе своей работы).    
Но при этом естественный язык очень сложен и изменчив. Программа в точности не умеет определять контекст (даже человек не всегда может), поэтому программно работать с естественным языком в полной мере можно на довольно огранниченных условиях (например как в условии данной задачи), или на более широких, но вводя гигантские грамматики и большое количество всевозможных написаний множества разных слов. Немного лучше с этим справляются нейронные сети, которые обучаются сами на основе реальной человеческой речи (и то до конца они не смогли в полной мере освоить наш язык).
