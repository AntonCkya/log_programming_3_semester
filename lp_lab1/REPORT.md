# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Синюков А.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пролог оказался слишком непохож от традиционных языков программирования. Учась писать программы на нем я как будто заново учился программировать, ближайшее что хоть немного похоже на пролог это нормальные алгоритмы Маркова, но они не предоставляют достаточного функционала для написания полноценных приложений и вообще другие.
Списки как в Прологе можно встретить в других языках программирования (напимер LinkedList в java), но зачастую в них используются редко, давая предпочтение массивам с констатнтным доступом к ячейкам памяти. Такие списки часто используются в олимпиадном программировании, на их основе пишутся классические структуры данных (стеки и очереди).
Многие предикаты, которые были бы полезны при обработке данных не реализованны в Прологе "из коробки", что заставляет их реализовывать вручную (в той же java LinkedList имеет больше встроенных функций).

## Задание 1.1: Предикат обработки списка

`remove_last(X, Y).` - удаляет последний элемент списка

Примеры использования:
```prolog
?- remove_last([1,2,3,4,5], X).
X = [1, 2, 3, 4] ;
?- remove_last(X, [1,2,3]).
X = [1, 2, 3, _].
```

Реализация:
```prolog
remove_last([_], []).
remove_last([A|T], [A|R]) :- remove_last(T, R).
```

Предикат идёт рекурсивно до последнего элемента списка, а потом удаляет его.

## Задание 1.2: Предикат обработки числового списка

`count_chet(X, Y)` - считает количество чётных чисел в списке

Примеры использования:
```prolog
?- count_chet([1,2,3,4,5,6,8],X).
X = 4.
?- count_chet([1,2,3,4,5,6,8],X).
X = 4.
```

Реализация:
```prolog
count_chet([], 0) .
count_chet([A|Y], N) :- count_chet(Y, N1), N is N1 + (A+1) mod 2 .
```

Предикат работает также как и length, обходит рекурсивно список с "счётчиком", но прибавляет не 1 а остаток от деления на 2 встреченного числа +1 (чтобы считались чётные а не нечётные).

## Задание 2: Реляционное представление данных

Реляционные модели (и базы данных в частности) обладают многими преимуществами : они удобны для написания алгоритмов обработки а также удобны для чтения пользователем (особенно в виде таблицы). Но также они имеют и недостаток - доступ за линейное время (конечномерные (расширяемые) массивы или списки "ключ-значение" имеют доступ за О(1), а деревья поиска за О(logn) ).
Конкретно в данном представлении (1) удобнее всего вносить новую информацию, нетрудно добавить новый предмет, студента, оценку. Но при этом чтобы получить данные о группе, предмете либо студенте нужно обработать все предикаты, что не только долго по времени но и достаточно сложно реализуемо.

`any_stud()` - для каждого студента находит средний балл и сдал ли он экзамены или нет

Примеры использования:
```prolog
Круглотличников
4.166666666666667
Всё сдал(а)
--------------------------------------------------
Вебсервисов
3.3333333333333335
Есть задолженности
--------------------------------------------------
Азурин
3.3333333333333335
Есть задолженности
--------------------------------------------------
(и т.д.)
```

Реализация:
```prolog
avg(X, AVG) :- findall(N, grade(X,_,N), ARR), sum(ARR, SUM), length(ARR, LEN), AVG is SUM / LEN.

all_passed(X, RES) :- findall(N, grade(X,_,N), ARR), (not(member(2, ARR)) -> RES is 1 ; RES is 0).

avg_passed(X, AVG, RES) :- avg(X, AVG), all_passed(X, RES).

any_stud() :- findall(X, student(_,X), ARR), any_stud(ARR).
any_stud([]).
any_stud([X|Y]) :- any_stud(Y), avg_passed(X, AVG, RES), writeln(X), writeln(AVG), (RES = 1 -> writeln('Всё сдал(а)') ; writeln('Есть задолженности')), writeln('--------------------------------------------------').
```

Предикат получает список всех студентов, ищет среди каждого по имени его средний балл (другой предикат, среди всех оценок считает среднюю), и есть ли задолженности (предикат, ищет оценки 2 среди списка всех оценок).

`any_subj()` - для каждого предмета находит количество не сдавших студентов

Примеры использования:
```prolog
?- any_subj().
Психология
5
---------------------------------------
Английский язык
1
---------------------------------------
Информатика
3
---------------------------------------
Функциональное программирование
1
---------------------------------------
Математический анализ
6
---------------------------------------
Логическое программирование
3
---------------------------------------
true.
```

Реализация:
```prolog
count_fail(NAME, X) :- findall(N, grade(N, NAME, 2), ARR), length(ARR, X).

full_subj(X, Y) :- subject(X, Y).

any_subj() :- findall(X, subject(X, _), ARR), any_subj(ARR).
any_subj([]).
any_subj([X|Y]) :- any_subj(Y), count_fail(X, N), full_subj(X, XFULL), writeln(XFULL), writeln(N), writeln('---------------------------------------').
```

Предикат получает списко всех предметов, для каждого предмета ищет оценки всех студентов и среди них ищет оценки 2 (за это отвечает отдельный предикат count_fail(NAME, X) ).

`best_stud()` - для каждой группы находит студента (студентов) с максимальным средним баллом

Примеры использования:
```prolog
?- best_stud().
104
Иванов
Фулл
---------------------------------------
103
Сиплюсплюсов
Клавиатурникова
---------------------------------------
102
Шарпин
---------------------------------------
101
Петровский
---------------------------------------
```

Реализация:
```prolog
minus_one(X,Y) :- Y is X - 1.

maxlist([],0).
maxlist([A|B],MAX) :-
    maxlist(B,C),
    A > C,
    MAX is A.
maxlist([A|B],MAX) :-
    maxlist(B,C),
    A =< C,
    MAX is C.


all_avg(X, GR) :-
	findall(N, student(GR,N), ARR),
	length(ARR, LEN),
	all_avg(X, ARR, GR, LEN).
all_avg(X, ARR, _, 0) :- append([], ARR, X).
all_avg(X, [A|B], GR, L) :-
	minus_one(L, L1),
	avg(A, AVG),
	append(B, [AVG], X1),
	all_avg(X, X1, GR, L1).
	
max_group_avg(X, GR) :- all_avg(ARR, GR), maxlist(ARR, X).

stud_by_group_avg(GR, AVG) :- findall(N, student(GR,N), ARR), stud_by_group_avg(GR, AVG, ARR).
stud_by_group_avg(_, _, []).
stud_by_group_avg(GR, AVG, [A|B]) :-
	avg(A, AVG),
	writeln(A),
	stud_by_group_avg(GR, AVG, B).
stud_by_group_avg(GR, AVG, [A|B]) :-
	stud_by_group_avg(GR, AVG, B),
	not(avg(A, AVG)).

best_stud() :- best_stud([101, 102, 103, 104]).
best_stud([]).
best_stud([A|B]) :-
	best_stud(B),
	writeln(A),
	max_group_avg(AVG, A),
	stud_by_group_avg(A, AVG),
	writeln('---------------------------------------').
```

1)all_avg - находит средние баллы всех студентов группы и заносит в список
2)stud_by_group_avg - выводит всех студентов данной группы с данным средним баллом
3)best_stud - идёт по списку групп (по условию задачи он заранее известен [101, 102, 103, 104] ), находит в каждой максимальный средний балл (all_avg + предикат нахождения максимума в списке maxlist) и всех студентов с таким средним баллом (для удобства студентов выводит предикат stud_by_group_avg).

## Выводы

Обработка данных и написание собственных функций обработки списков оказалось очень сложной задачей на Прологе. Привычка писать в "традиционном стиле" практически не пропадала, из-за этого очень часто программа выводила true/false вместо результата, уходила в вечную рекурсию или выдавала ошибки (особенно "Arguments are not sufficiently instantiated" часто виднелось перед глазами, хотя достаточно было поменять местами 2 предиката). Каждый раз когда программа успешно выполнялала поставленную задачу вызывало восторг, который я испытывал в последний раз когда только учился программировать лет 7 назад.
Но при этом написание кода на Прологе вызывало гнев. Я понимал, что каждую из функций мог написать раза в 4 быстрее на Си или раз в 10 быстрее на модном Python. Логическое программирование иногда казалось настолько нелогичным, но разобравшись начинаешь понимать его суть. Возможно, знания о логическом программировании мне пригодятся в будущем (напимер в функциональном), но всё же программировать на процедурных/ООП языках куда удобнее и комфортнее.
Благодаря данной лабораторной работе я всё-таки разобрался как работать со списками в Прологе, научился писать собственные предикаты и научился некоторым конструкциям, которые приближённо походят на конструкции традиционных языков (например 2 предиката для истины/лжи или замена этому с помощью ->), научился писать полноценный консольный вывод с помощью предиката write().
